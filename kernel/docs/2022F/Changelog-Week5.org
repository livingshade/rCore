#+title: 更新日志（第五周）

下面是第五周（后半）的更新记录。前半以及各周索引在 [[./Changelog.org][Changelog.org]]。

* 使用 eBPF+kProbes 与 tokio-rs/console 整合可行性考察

从上到下：
- =tokio-rs/console= :: 数据的接收方，对数据整理并进行可视化。
- =gRPC=, =protobuf= :: 数据的承载格式以及交换方法。
- 用户态程序 :: 从 eBPF 处接收数据，中转站。
- eBPF 程序 :: 从内核各处获取相应信息。（下面会汇总一下“相应”信息大概有什么。）
- Async Runtime :: 提供协程的上下文信息。

为此，我们需要：
- 把数据最终送到 =tokio-rs/console= ：操作系统需要有网络或 socket 实现。
- 用户态程序从 eBPF 获取信息：目前来看最方便的需要实现 perf events 相关的内容。
- eBPF 程序获取信息：kProbes 相关，另外在 Async Runtime 里也要插入一些位点。
- Async Runtime：需要改代码来收集上下文信息，但是 rCore 用的 runtime 看起来比较简单还好。

可收集的相关信息主要是异步的 pollable 资源信息，包括：
- 任务信息
- 资源信息（例如锁等）

这可能要对 Rust 的异步机制有更深一点的认识。希望上面的信息都能在 async runtime 里收集到吧，不然 kProbes 也救不了。

另外上学期同学实现的内容似乎还不足以实现 eBPF 和用户态的有效通信。网络 IO（或者 QEMU 有速度快点的 serial 吗）可能也够呛。当然把 =tokio-rs/console= 整个放到用户态里也是一种办法。

** 计划

把 Rust 异步的 poll 机制以及 rCore（或者跑去 zCore 看看？）里的 async runtime 的整合看一看。

* eBPF 解释器构建
在 [2022-10-12 Wed] 大致结束。

解释器要说的话写起来是比较简单的，但是因为 interpreter 和 verifier 的代码逻辑有相当一步分是重合的，所以设计时预留了一定的扩展性
——或者可以说写完 interpreter 后 verifier 进度就有 10% 了（代码量可能比例更多，但是后面没法照抄 Linux 思路了）。

现在留了两个 verifier 可用的地方：
- =Value= trait :: 跟踪对某一个值的操作。解释器里所有的对 eBPF 虚拟机内数值的操作都经过了这个 trait 的封装。
- =BranchTracker= trait :: 跟踪跳转以及跳转对应的目标条件。解释器会在 tracker 有需要的时候停下来把控制权交回 verifier，以便进行分支遍历等操作。

** 下面计划

- =BPF_CALL= 实现：
  - 我实在没有找到什么文档。现在看起来有几种 =BPF_CALL= （可能重合）：
    - 调用 kfuncs
    - 调用同一个 ELF 文件内其它代码段的函数（可能需要用尾递归的 kfuncs）
    - 调用同一段内的某个位置的函数
  - 总之是好乱……暂时不想实现，可能 verifier 差不多之后和 JIT 那边统一一下接口再说。
- 值跟踪：把 =Value= trait 给实现一遍，跟踪算法看看能不能按 Linux 的来……
  - [[https://docs.kernel.org/bpf/verifier.html]] 这里是简要的概述，大概看得出是使用 =tnum (mask+value)= 跟踪位信息，同时跟踪有符号 & 无符号可能的最大最小值。
  - [[https://bbs.pediy.com/thread-267956.htm]] 找到一篇分析，但其实也非常简略，但是给出了对应算法所在函数：
    - =adjust_reg_min_max_vals= :: 值的上下界计算
    - =check_max_stack_depth= :: 函数调用的检查
  - 一些要检查的内容：
    - 指针与数值：
      - 指针与指针的运算只允许减法，只允许同一块数据上的指针进行运算。
      - 指针与数值允许加减法
      - 数值之间自由运算
    - 指针解引用：
      - 指向定长的 =struct= 的指针，需要保存对应类型的信息，offset 多少的地方对应的是多大的数据类型，不能把 =char *= 当 =u64= 读了，不能把 =i32= 当 =u8= 读了。
      - 指向不定长的，例如数据包的指针，需要对长度做判断及推断。见内核文档的例子。
    - 数值/指针相对关系推断：
      - 例如： =p1, p2= 为一个数据的开头结尾，数据大小未知，则 =if (p2 - p1 > 7)= 之后应能推断出 =p1[6]= 是可以访问的。
        当然，如果是 =if (p1 - p2 > 7)= 则可能有溢出的情况，所以不能得出 =p2[6]= 的结果。
      - 例如： =for (int i = 0; i < 100; ++i) {}= 则执行这一段过后 =i= 对应的寄存器必定为 100。
      - =if (i < j && j < k)= 之后有 =i < k && k - i > 2= 。
    - 未初始化值的跟踪：
      - 退出前函数调用的 callee saved 寄存器需要恢复，可以用特殊类型的指针表示。
      - （虽然我们还没有实现 =BPF_CALL= ……）函数调用后，R1 到 R5 设为未初始化值。
    - 总结：
      - 值之间有依赖关系，比较时可能要把整棵树搜索一遍避免成环。简单起见我们只追踪加减的大小关系，乘除放弃。
      - 指针之间的关系通过一个隐形的长度值来表示，指针有类型以及所属信息，不同数据对应的指针之间无法比较。
- 跳转跟踪：主要需要根据分支条件对分支之后对应的数据进行推断。
  - 不知道 Linux 现在怎么做的，可能可以设一个跳转上限。
  - 最好做些分支合并，也许可以牺牲一些跟踪数据的精度。
