#+title: 更新日志

* 尝试把之前同学 eBPF 的代码跑起来
从 [2022-10-02 Sun] 到 [2022-10-03 Mon]，还没成功。

#+begin_quote
虽然还没有决定是要尝试 eBPF 方向还是 swap 那边，所以先把复现一下再说。
但是前面同学实现的 backtrace 还挺方便的，所以无论是 swap 还是进一步加强 eBPF 应该都会基于这个分支。
#+end_quote

下面直接把 commit message 复制过来了：

    Bumped dependency versions to get things compiled
    
    * Updated rust-toolchain
    * Bumped dependency versions
      - trapframe
      - buddy_system_allocator
      - executor
      - isomorphic_drivers
      - riscv (previous versions causing page faults)
    * Blindly removed some features
      - nll
      - untagged_unions
      - optin_builtin_traits
      - global_asm
      - alloc_prelude
      - const_fn
      - const_in_array_repeat_expressions
    * Modified Makefile, no idea if done correctly
    * Replaced llvm_asm! with asm! (for RISC-V only)
    * Removed read_user_fixup, no idea what is it for

因为想用 ~asm!~ 取代 ~llvm_asm!~ 所以把整个依赖以及 toolchain 胡乱升级了一遍。
最后到了 shell 出现提示符，但是不能输入内容，现在还在顺着 async 链来找是哪出了问题。

另外看到同学[[https://zhuanlan.zhihu.com/p/137733625][下一代 Rust OS：zCore 正式发布 - 知乎]]的文章，里面说：

#+begin_quote
对于 Rust，Fuchsia 官方上个月发布的一份语言政策（知乎上也有所讨论）中明确表示，不会将 Rust 用于编写内核，原因是内核要使用工业级别的稳定技术：

    Rust is approved for use throughout the Fuchsia Platform Source Tree, with the following exceptions:
    * kernel. The Zircon kernel is built using a restricted set of technologies that have established industry track records of being used in production operating systems.

而我们希望通过 zCore 的实践表明：Rust 是适合编写内核级代码的，并且比 C/C++ 更能胜任这一任务。
#+end_quote

只能说，nighty 它的名字就意味着不可能是“工业级别稳定”。
从现在人人都用 nightly 版本的状况来看，要跟上 Rust 的版本更新本身就是一个非常大的维护开销。
这种东西也不是说自己项目管理做好了就可以的，而是你想要更新你必须确保你所用的所有库都可以顺利更新。
谷歌不知道，rCore 的依赖库有多少 fork 过来的现在都抛荒了都。

** debug 笔记

尝试跑起来的时候被一个上游库的 bug 卡了好久，但也因此稍微熟悉了一下 debug 的流程。

*** 流程

工具无非就是 GDB 以及 QEMU，但是课程上并没有太讲 QEMU Console 的使用。如果想要更随心所欲地查看虚拟机状态，那么可以尝试一下 QEMU Console，按 =Ctrl+X C= 进入。
Makefile 的 debug 里 QEMU 是后台运行的，没法直接进入 Console，需要多打几个命令。（另外调用的似乎是 x86_64 的 GDB，所以反汇编全是错的。）

#+begin_src console
  $ cd kernel
  $ # 在一个终端输入：
  $ make build justdebug ARCH=riscv64 LOG=debug SMP=1
  $ # 另开一个终端：
  $ RUST_GDB=riscv64-unknown-elf-gdb rust-gdb target/riscv64/release/rcore -x ../tools/gdbinit
#+end_src

Console 的几个常用命令：

- ~info mem~ :: 页表！一览无余。
- ~info registers~ :: Privileged 的各种寄存器都有。
- ~log item1[,item2[,...]]~ :: 开启某样日志，或用 ~log none~ 关闭。
  可以与 GDB 配合获取某一段执行期间的详尽日志。（不然真的看不过来。）
- ~xp /8xg 0x03fff000~ :: 例如查看 0x3fff000 此处物理地址的内容。
  前面的 =/8xg= 里的 =g= 指以 =u64= 为输出单位， =8= 表示输出 8 个单位， =x= 十六进制。

*** 上游的一个 bug

是 [[https://github.com/rcore-os/riscv/]] 的一个小 bug，已经提了 [[https://github.com/rcore-os/riscv/pull/8][PR]]。
基本上就是页表的非根节点的 A/D 位必须为 0，但是库里为了兼容 U540 把所有有效页表项的 A/D 位硬性写成 1 了，本来这件事应该是操作系统来选择而不是由库来干的。

大概只在 QEMU 7.0 或以上版本出现，因为之前版本很宽松而没有检查这一点。

#+begin_quote
Debug 流程挺痛苦的，又有谁能想得到呢……基本上是：
1. QEMU Console ~info mem~ 发现页表完完全全正确。
2. ~log mmu~ 打印日志，最后没办法了，顺着日志找到 QEMU 源代码实现页表查找的代码。
3. 看了几遍，不好找。假设是最近引入的问题，用 =git blame= 找到一个几个月前引入这个检查的 commit。
4. 回去 ~info registers~ 看 =satp= ，找根页表逐级找下去发现 A/D 位是 1。
5. 接下来只要找到对应代码就可以了。

题外话：
我这里是因为设置了 A/D 而 page fault，但是其实 U540 没有设置 A/D 位也会报错这一点也在标准里写了：
硬件不支持实时设置 A/D 位就会 page fault。这一点应该是给操作系统软件补全留出空间。说不定当时的同学调 U540 板也痛苦了好久……
#+end_quote

* 尝试跑起来（其二）：输入问题
[2022-10-04 Tue]

** Async 的调用“栈”

大概看起来的流程是 ppoll -> poll -> 先挂起，等中断传过来之后通过哪里的 bus 用对应的 waker 唤起携程来执行。

但是……目前看起来 UART 完全没有中断传过来，因为没有其它外设中断，所以也不知道只是 UART 有问题还是怎样。
跑去看了 =mie= 寄存器，没问题。
跑去用 ~xp /1xb 0x1000000N~ 看了一下 UART 寄存器的内容，没问题。（ 似乎 QEMU 只支持一字节一字节地看。）

** PLIC 根本没有初始化

回去看[[https://learningos.github.io/rCore-Tutorial-Book-v3/chapter9/2device-driver-1.html][外设平台与串口驱动程序 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档]]，发现原来还有一个 PLIC，
然后打点发现 PLIC 初始化代码压根没有运行……
最后发现是 =compatible= 属性原来应该是当作一个字符串列表来处理的，但是代码里把它当作整一个字符串了……

去看了一下 device tree 规范，从最开始的 v0.1 =compatible= 就是 =stringlist= 类型……
顺便看了一下 QEMU，这次是 6.1 版本开始就会有的问题，由[[https://github.com/qemu/qemu/commit/60bb5407f02b9d7cf7078ff339cbae961b7e98cc][这个 commit]] 引进。

#+begin_quote
Property name: compatible
Value type: <stringlist>
#+end_quote

rCore 文档里也认为它是个字符串……为了不误导太多人总之去给提了个 PR。 +和硬件打交道想当然而不看规范那真机跑出问题不是当然的吗……+
好了，大致问题消除，可以开始想后面做什么了。

* eBPF Verifier
大概 [2022-10-05 Wed] 开始？

去看了相关的一些文章，内核代码 15k 行没敢去看……

- 指令集：
  - [[https://docs.kernel.org/bpf/instruction-set.html][eBPF Instruction Set - The Linux Kernel documentation]]
  - [[https://github.com/iovisor/bpf-docs/blob/master/eBPF.md][Unofficial eBPF spec - iovisor/bpf-docs]]
    这个和上面的有些不符……例如 =0x87= 的 =NEG= 指令。
  - [[https://www.kernel.org/doc/Documentation/networking/filter.txt][Linux Socket Filtering aka Berkeley Packet Filter (BPF)]]
    这个大概是（除了直接看代码之外）最官方的？
    还没开始看，可以从 /BPF kernel internals/ 这一节看。
- Verifier：
  感想是这真的是我能写的吗……
  - [[https://docs.kernel.org/bpf/verifier.html][eBPF verifier - The Linux Kernel documentation]]
    大概把要检查的东西以及检查逻辑说了一遍。
  - [[https://lwn.net/Articles/794934/][Bounded loops in BPF for the 5.3 kernel]]
    令人头大。摘两个点：
    - State pruning
    - 对寄存器/栈里的值的逻辑推断。

其它一些现有的用户态的实现似乎都不太验证程序，毕竟用户态嘛……

+要不咱们不验证了吧？+

** 进度

*** DONE 验证单个指令的正确性

- 简便起见，禁止使用旧的 BPF 的指令。
- 规范里说指令里未使用的域 *应* 置零，我们这里强制 *必须* 置零。
- 原子操作的数据长度是 32 位或 64 位。至于真正的支持那留给 JIT 了。
- 寄存器，R10 是只读的，其它十个可读可写。

*** DONE 简单的结构检查

- 不允许不可达的代码。但是 ~if 0~ 或者更复杂的逻辑上不可达的我们没法判断。
- 不允许越界的跳转，例如跳到代码块外，跳到指令中间（128 位的宽指令）或是跳到当前指令。
- 不允许 open-ended 的代码块，也就是一个代码块最后要不是跳转走，要不必须 BPF_EXIT 返回。

*** TODO 复杂的状态枚举检查

- [ ] 值的推断信息记录、更新、合并
  - [ ] 指针
  - [ ] 整型
- [ ] 实现一个推断使用的 VM
- ...

**** 一些检查要点

- 值可以是这些类型：
  - 未初始化：完全不能使用，只能被覆盖。
  - 指针：不同允许进行的操作不同，要储存已知以及推断信息。
  - 整型：要储存推断信息，例如每一位的可能状态以及大小范围等等（要检查溢出）。

- 要检查 callee saved 寄存器是不是被还原了。
- 对操作/每一个调用函数都需要知道它们对参数类型需求并检查。
- 循环不允许深度太大。

**** 一些思路

- +思路一：放弃。+
- 思路二：
  - 和解释器对照着写，感觉上还是挺相像的，毕竟验证也需要知道每一步的具体语义以及副作用等等。做梦的话能用不同的 trait 实现来让解释器直接变成验证器就最好了。
  - 在之前分块的基础上，记录下每一个代码块需要访问/修改的值。这样大概可以在分支的时候做点分支合并的工作。
  - 另外可能还有一个省事的思路，就是在 JIT 的时候插检查指令，例如给循环记个数什么的。
  - 最后的思路就是把“太复杂”的程序全部拒掉（

*** TODO 测试、文档、开源

遥遥遥遥无期。

** 看的一些其它内容

- [[https://lwn.net/Articles/645169/][bpf: introduce bpf_tail_call() helper]]
  现在对 eBPF 可以做的东西还没有一个概念。
  看起来现在 Linux 是可以把不同的函数放在一个 ELF 的不同段里然后调用？
  但是这要怎么检查相互调用……（尾递归优化就先不要想了吧。）
- [[https://docs.kernel.org/bpf/btf.html][BPF Type Format (BTF) - The Linux Kernel documentation]]
  Debug 信息，例如 verifier 可以给出更详细的出错信息。
